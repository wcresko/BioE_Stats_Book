{
  "hash": "b5f3ac9584e538e6d1012a473761ac3b",
  "result": {
    "engine": "knitr",
    "markdown": "# Sampling and Parameter Estimation {#sec-sampling-estimation}\n\n\n::: {.cell}\n\n:::\n\n\n## The Problem of Inference\n\nScience often works by measuring samples to learn about populations. We cannot measure every protein in a cell, every patient with a disease, or every fish in the ocean. Instead, we take samples and use statistical inference to draw conclusions about the larger populations from which they came.\n\nThis creates a fundamental challenge: sample statistics vary from sample to sample, even when samples come from the same population. If you take two different random samples from a population and calculate their means, you will almost certainly get two different values. How, then, can we say anything reliable about the population?\n\nThe answer lies in understanding the sampling distribution—the distribution of a statistic across all possible samples of a given size.\n\n## Parameters and Statistics\n\nA **parameter** is a numerical characteristic of a population—the true population mean $\\mu$, the true population standard deviation $\\sigma$, the true proportion $p$. Parameters are typically fixed but unknown.\n\nA **statistic** is a numerical characteristic of a sample—the sample mean $\\bar{x}$, the sample standard deviation $s$, the sample proportion $\\hat{p}$. Statistics are calculated from data and vary from sample to sample.\n\nWe use statistics to estimate parameters. The sample mean $\\bar{x}$ estimates the population mean $\\mu$. The sample standard deviation $s$ estimates the population standard deviation $\\sigma$. These estimates will rarely equal the true parameter values exactly, but we can quantify how close they are likely to be.\n\n## Point Estimates\n\nA **point estimate** is a single number used as our best guess for a parameter. The sample mean is a natural point estimate for the population mean:\n\n$$\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i$$\n\nWhat makes a good estimator? Ideally, an estimator should be:\n\n**Unbiased**: On average, across many samples, the estimator equals the true parameter. The sample mean is an unbiased estimator of the population mean.\n\n**Efficient**: Among unbiased estimators, it has the smallest variance. The sample mean is the most efficient estimator of a normal mean.\n\n**Consistent**: As sample size increases, the estimator converges to the true parameter value.\n\n## The Sampling Distribution of the Mean\n\nImagine drawing all possible samples of size $n$ from a population and calculating the mean of each. The distribution of these means is the sampling distribution of the mean.\n\nThe sampling distribution has remarkable properties:\n\n1. Its mean equals the population mean: $E[\\bar{X}] = \\mu$\n2. Its standard deviation (the **standard error**) equals: $SE = \\frac{\\sigma}{\\sqrt{n}}$\n3. For large samples, it is approximately normal (Central Limit Theorem)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Demonstrate sampling distribution\nset.seed(32)\n\n# Create a population\ntrue_pop <- rpois(n = 10000, lambda = 3)\npop_mean <- mean(true_pop)\npop_sd <- sd(true_pop)\n\n# Take many samples and compute their means\nsample_sizes <- c(5, 20, 50, 200)\npar(mfrow = c(2, 2))\n\nfor (n in sample_sizes) {\n  sample_means <- replicate(1000, mean(sample(true_pop, n)))\n  hist(sample_means, breaks = 30, main = paste(\"n =\", n),\n       xlab = \"Sample Mean\", col = \"steelblue\",\n       xlim = c(1, 5))\n  abline(v = pop_mean, col = \"red\", lwd = 2)\n}\n```\n\n::: {.cell-output-display}\n![](10-sampling-estimation_files/figure-html/unnamed-chunk-2-1.png){width=768}\n:::\n:::\n\n\nAs sample size increases, the sampling distribution becomes narrower (smaller standard error) and more normal in shape. This is why larger samples give more precise estimates.\n\n## Standard Error\n\nThe **standard error** (SE) measures the variability of a statistic across samples. For the sample mean:\n\n$$SE_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}}$$\n\nSince we usually do not know $\\sigma$, we estimate the standard error using the sample standard deviation:\n\n$$\\widehat{SE}_{\\bar{x}} = \\frac{s}{\\sqrt{n}}$$\n\nThe standard error shrinks as sample size increases, but following a square root relationship. To halve the standard error, you need to quadruple the sample size.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Demonstrate how SE changes with sample size\nset.seed(32)\ntrue_pop <- rpois(n = 1000, lambda = 5)\n\n# Sample size of 5\nsamps_5 <- replicate(n = 50, sample(true_pop, size = 5))\nmeans_5 <- apply(samps_5, 2, mean)\nse_5 <- sd(means_5)\n\n# Sample size of 50\nsamps_50 <- replicate(n = 50, sample(true_pop, size = 50))\nmeans_50 <- apply(samps_50, 2, mean)\nse_50 <- sd(means_50)\n\ncat(\"Standard error with n=5:\", round(se_5, 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStandard error with n=5: 0.919 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Standard error with n=50:\", round(se_50, 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStandard error with n=50: 0.305 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Ratio:\", round(se_5/se_50, 2), \"(theoretical: √10 =\", round(sqrt(10), 2), \")\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRatio: 3.01 (theoretical: √10 = 3.16 )\n```\n\n\n:::\n:::\n\n\n![](../images/week_2.026.jpeg){fig-align=\"center\"}\n\n## Confidence Intervals\n\nA point estimate tells us our best guess, but not how uncertain we are. A **confidence interval** provides a range of plausible values for the parameter along with a measure of confidence.\n\nA 95% confidence interval for the population mean, when the population is normally distributed or the sample is large, is:\n\n$$\\bar{x} \\pm t_{\\alpha/2} \\times \\frac{s}{\\sqrt{n}}$$\n\nwhere $t_{\\alpha/2}$ is the critical value from the t-distribution with $n-1$ degrees of freedom.\n\n![](../images/week_2.027.jpeg){fig-align=\"center\"}\n\nThe interpretation requires care: a 95% confidence interval means that if we repeated this procedure many times, 95% of the resulting intervals would contain the true parameter. Any particular interval either does or does not contain the true value—we just don't know which.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate a confidence interval\nset.seed(42)\nsample_data <- rnorm(30, mean = 100, sd = 15)\n\nsample_mean <- mean(sample_data)\nsample_se <- sd(sample_data) / sqrt(length(sample_data))\nt_crit <- qt(0.975, df = length(sample_data) - 1)\n\nlower <- sample_mean - t_crit * sample_se\nupper <- sample_mean + t_crit * sample_se\n\ncat(\"Sample mean:\", round(sample_mean, 2), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSample mean: 101.03 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"95% CI: [\", round(lower, 2), \",\", round(upper, 2), \"]\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n95% CI: [ 94 , 108.06 ]\n```\n\n\n:::\n\n```{.r .cell-code}\n# Or use t.test directly\nt.test(sample_data)$conf.int\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  93.99927 108.05833\nattr(,\"conf.level\")\n[1] 0.95\n```\n\n\n:::\n:::\n\n\n![](../images/week_2.028.jpeg){fig-align=\"center\"}\n\n## The Central Limit Theorem in Practice\n\nThe Central Limit Theorem (CLT) is one of the most remarkable results in statistics. It states that the sampling distribution of the mean approaches a normal distribution as sample size increases, regardless of the shape of the underlying population distribution.\n\nThis is why confidence intervals work. This is why the normal distribution appears everywhere in statistics. And understanding the CLT in practice—through examples like polling and surveys—builds deep intuition for statistical inference.\n\n### The CLT Demonstrated\n\nLet's see the CLT in action with a highly non-normal distribution. We'll sample from an exponential distribution (heavily right-skewed) and watch how the sampling distribution of the mean becomes normal:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\n\n# Exponential distribution (very skewed)\nrate <- 0.5\npop_mean <- 1/rate  # True mean = 2\n\npar(mfrow = c(2, 2))\n\n# Original population\nx <- rexp(10000, rate = rate)\nhist(x, breaks = 50, main = \"Original Distribution (Exponential)\",\n     xlab = \"Value\", col = \"gray80\", probability = TRUE)\ncurve(dexp(x, rate = rate), add = TRUE, col = \"red\", lwd = 2)\n\n# Sample means for different n\nfor (n in c(5, 30, 100)) {\n  sample_means <- replicate(5000, mean(rexp(n, rate = rate)))\n  hist(sample_means, breaks = 50, probability = TRUE,\n       main = paste(\"Sampling Distribution (n =\", n, \")\"),\n       xlab = \"Sample Mean\", col = \"steelblue\")\n\n  # Overlay normal curve with theoretical SE\n  theoretical_se <- (1/rate) / sqrt(n)\n  curve(dnorm(x, mean = pop_mean, sd = theoretical_se),\n        add = TRUE, col = \"red\", lwd = 2)\n}\n```\n\n::: {.cell-output-display}\n![](10-sampling-estimation_files/figure-html/unnamed-chunk-5-1.png){width=864}\n:::\n:::\n\n\nEven with n = 30, the sampling distribution of the mean is remarkably close to normal, despite the exponential distribution being extremely skewed. By n = 100, the approximation is nearly perfect.\n\n### Margin of Error: Quantifying Precision\n\nThe **margin of error** (MOE) is a practical expression of sampling uncertainty. For a confidence interval around a proportion or mean, the margin of error is the half-width of the interval:\n\n$$\\text{Margin of Error} = z^* \\times SE$$\n\nFor a 95% confidence interval, $z^* \\approx 1.96 \\approx 2$, giving us the approximation:\n\n$$\\text{95% MOE} \\approx 2 \\times SE$$\n\nFor proportions, the standard error is $SE = \\sqrt{\\frac{p(1-p)}{n}}$, so:\n\n$$\\text{95% MOE} \\approx 2 \\times \\sqrt{\\frac{p(1-p)}{n}}$$\n\nThe maximum standard error for a proportion occurs when $p = 0.5$, giving the conservative formula used in sample size planning:\n\n$$\\text{Maximum 95% MOE} \\approx \\frac{1}{\\sqrt{n}}$$\n\n### Polling as a Statistical Inference Problem\n\nPolitical polling provides an excellent practical example of sampling and the CLT. When a poll reports \"48% of voters support Candidate A, with a margin of error of ±3%,\" they are making a statistical inference from a sample to a population.\n\nLet's simulate an election poll:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\n# True population proportion (unknown in real life)\ntrue_proportion <- 0.52  # 52% actually support the candidate\n\n# Simulate a poll of 1000 likely voters\nn <- 1000\npoll_sample <- rbinom(1, size = n, prob = true_proportion) / n\n\n# Calculate margin of error\nse <- sqrt(poll_sample * (1 - poll_sample) / n)\nmoe <- 1.96 * se\n\ncat(\"Poll result:\", round(poll_sample * 100, 1), \"%\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPoll result: 53.2 %\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Margin of error: ±\", round(moe * 100, 1), \"%\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMargin of error: ± 3.1 %\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"95% CI: [\", round((poll_sample - moe) * 100, 1), \"%, \",\n    round((poll_sample + moe) * 100, 1), \"%]\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n95% CI: [ 50.1 %,  56.3 %]\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"True proportion:\", true_proportion * 100, \"%\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue proportion: 52 %\n```\n\n\n:::\n:::\n\n\n### How Sample Size Affects Margin of Error\n\nThe margin of error is inversely proportional to $\\sqrt{n}$. This has important practical implications:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Margin of error as a function of sample size\nsample_sizes <- c(100, 400, 1000, 2000, 4000, 10000)\np <- 0.5  # Conservative estimate\n\nmoe_values <- 1.96 * sqrt(p * (1 - p) / sample_sizes) * 100\n\nplot(sample_sizes, moe_values, type = \"b\", pch = 19,\n     xlab = \"Sample Size\", ylab = \"Margin of Error (%)\",\n     main = \"95% Margin of Error vs. Sample Size\",\n     log = \"x\", col = \"steelblue\", lwd = 2)\ngrid()\n\n# Add labels\ntext(sample_sizes, moe_values + 0.5,\n     paste0(\"±\", round(moe_values, 1), \"%\"),\n     cex = 0.8)\n```\n\n::: {.cell-output-display}\n![](10-sampling-estimation_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nNotice the diminishing returns: going from n = 100 to n = 400 cuts the margin of error in half (from ±10% to ±5%). But to halve it again (to ±2.5%), you need n = 1,600—four times as many respondents. This is why most national polls use samples of 1,000–2,000: it provides reasonable precision (±2-3%) at manageable cost.\n\n### Interpreting Polls: Uncertainty in Action\n\nWhen two candidates are within the margin of error of each other, the poll results are consistent with either candidate leading. This is not a flaw of polling—it reflects genuine uncertainty.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(456)\n\n# Simulate many polls from the same population\ntrue_p <- 0.48  # Candidate A's true support\nn_poll <- 1000\nn_polls <- 100\n\npolls <- replicate(n_polls, {\n  sample_p <- rbinom(1, n_poll, true_p) / n_poll\n  se <- sqrt(sample_p * (1 - sample_p) / n_poll)\n  c(estimate = sample_p, lower = sample_p - 1.96*se, upper = sample_p + 1.96*se)\n})\n\npolls_df <- data.frame(\n  poll = 1:n_polls,\n  estimate = polls[\"estimate\", ],\n  lower = polls[\"lower\", ],\n  upper = polls[\"upper\", ]\n)\n\n# How many CIs contain the true value?\ncoverage <- mean(polls_df$lower <= true_p & polls_df$upper >= true_p)\n\n# Plot first 30 polls\nggplot(polls_df[1:30, ], aes(x = poll, y = estimate)) +\n  geom_hline(yintercept = true_p, color = \"red\", linetype = \"dashed\", linewidth = 1) +\n  geom_hline(yintercept = 0.5, color = \"gray50\", linetype = \"dotted\") +\n  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.3, alpha = 0.6) +\n  geom_point(size = 2) +\n  labs(\n    title = \"95% Confidence Intervals from 30 Polls\",\n    subtitle = paste0(\"True proportion = \", true_p*100, \"% | \", round(coverage*100),\n                     \"% of all CIs contain true value\"),\n    x = \"Poll Number\",\n    y = \"Estimated Proportion\"\n  ) +\n  scale_y_continuous(labels = scales::percent_format()) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](10-sampling-estimation_files/figure-html/unnamed-chunk-8-1.png){width=768}\n:::\n:::\n\n\nIn repeated sampling, approximately 95% of confidence intervals contain the true value—but any single interval either does or does not contain it. This is the frequentist interpretation of confidence intervals.\n\n### Correct Language for Confidence Intervals\n\nConfidence intervals are frequently misinterpreted. The key insight is understanding *what is random* before and after data collection:\n\n::: {.callout-important}\n## What Is Random?\n\n**Before data collection**: The confidence interval is random—we don't yet know where it will fall. The population parameter $\\mu$ is fixed (though unknown).\n\n**After data collection**: The confidence interval is now fixed—it's just two numbers like [48.2, 52.1]. It either contains the true parameter or it doesn't. There is no probability involved anymore.\n:::\n\nConsider this analogy: Before flipping a coin, there's a 50% probability of heads. After flipping, the coin shows what it shows—there's no longer any probability, just an outcome.\n\nThe correct interpretation of a 95% confidence interval is:\n\n> \"If we repeated this sampling procedure many times, 95% of the resulting intervals would contain the true population parameter.\"\n\n**Incorrect interpretations** (which are very common):\n\n- ❌ \"There is a 95% probability that $\\mu$ is in this interval\"\n- ❌ \"We are 95% confident that $\\mu$ is between these values\"\n- ❌ \"95% of the data falls within this interval\"\n\nThe first two statements incorrectly assign probability to the parameter, which is fixed. The third confuses a confidence interval for a reference range.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visual demonstration: Monte Carlo simulation of CI coverage\nset.seed(2024)\n\n# True population parameters\ntrue_mean <- 50\ntrue_sd <- 10\nn <- 25  # Sample size\nn_simulations <- 100\n\n# Storage for confidence intervals\nci_data <- data.frame(\n  sim = 1:n_simulations,\n  lower = numeric(n_simulations),\n  upper = numeric(n_simulations),\n  contains_true = logical(n_simulations)\n)\n\n# Generate 100 confidence intervals\nfor (i in 1:n_simulations) {\n  sample_data <- rnorm(n, mean = true_mean, sd = true_sd)\n  ci <- t.test(sample_data)$conf.int\n  ci_data$lower[i] <- ci[1]\n  ci_data$upper[i] <- ci[2]\n  ci_data$contains_true[i] <- (ci[1] <= true_mean) & (ci[2] >= true_mean)\n}\n\n# Count how many contain the true mean\ncoverage <- mean(ci_data$contains_true)\n\n# Plot\nplot(NULL, xlim = c(42, 58), ylim = c(0, n_simulations + 1),\n     xlab = \"Value\", ylab = \"Simulation Number\",\n     main = paste0(\"100 Confidence Intervals (\", round(coverage*100), \"% contain true mean)\"))\n\n# Draw intervals\nfor (i in 1:n_simulations) {\n  color <- ifelse(ci_data$contains_true[i], \"steelblue\", \"red\")\n  segments(ci_data$lower[i], i, ci_data$upper[i], i, col = color, lwd = 1.5)\n}\n\n# True mean line\nabline(v = true_mean, col = \"darkgreen\", lwd = 2, lty = 2)\nlegend(\"topright\",\n       legend = c(\"Contains true mean\", \"Misses true mean\", \"True mean (μ = 50)\"),\n       col = c(\"steelblue\", \"red\", \"darkgreen\"),\n       lwd = c(2, 2, 2), lty = c(1, 1, 2))\n```\n\n::: {.cell-output-display}\n![](10-sampling-estimation_files/figure-html/unnamed-chunk-9-1.png){width=768}\n:::\n:::\n\n\nIn this simulation, each horizontal line represents a 95% confidence interval from a different random sample. The red intervals are the ~5% that failed to capture the true mean. Once calculated, each interval either contains the true value (blue) or doesn't (red)—there's no probability about it anymore.\n\n### The Practical Value of Margin of Error\n\nUnderstanding margin of error helps you:\n\n1. **Interpret reported results**: A poll showing 52% vs. 48% with ±3% MOE does not clearly favor either candidate\n2. **Plan studies**: Use $n \\approx \\frac{1}{\\text{MOE}^2}$ for proportions near 0.5 to achieve a desired margin of error\n3. **Communicate uncertainty**: Always report intervals, not just point estimates\n4. **Make decisions**: Consider whether differences are within or beyond the margin of error\n\nFor sample size planning, if you want a specific margin of error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Required sample size for different margins of error (95% CI)\ndesired_moe <- c(0.10, 0.05, 0.03, 0.02, 0.01)\nrequired_n <- ceiling((1.96 / desired_moe)^2 * 0.25)  # 0.25 = p(1-p) at p=0.5\n\ndata.frame(\n  `Margin of Error` = paste0(\"±\", desired_moe * 100, \"%\"),\n  `Required n` = required_n\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Margin.of.Error Required.n\n1            ±10%         97\n2             ±5%        385\n3             ±3%       1068\n4             ±2%       2401\n5             ±1%       9604\n```\n\n\n:::\n:::\n\n\nThese calculations assume simple random sampling. Real-world surveys often use complex sampling designs that affect the effective sample size.\n\n## Coefficient of Variation\n\nWhen comparing variability across groups with different means, the standard deviation alone can be misleading. The **coefficient of variation** (CV) standardizes variability relative to the mean:\n\n$$CV = \\frac{s}{\\bar{x}} \\times 100\\%$$\n\nA CV of 10% means the standard deviation is 10% of the mean. This allows meaningful comparisons between groups or measurements on different scales.\n\n## Percentiles and Quantiles\n\n**Percentiles** describe the relative position of values within a distribution. The $p$th percentile is the value below which $p$% of the data falls. The 50th percentile is the median, the 25th percentile is the first quartile, and the 75th percentile is the third quartile.\n\n**Quantiles** divide data into equal parts. Quartiles divide into four parts, deciles into ten parts, percentiles into one hundred parts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate percentiles\ndata <- c(12, 15, 18, 22, 25, 28, 32, 35, 40, 45)\n\nquantile(data, probs = c(0.25, 0.5, 0.75))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  25%   50%   75% \n19.00 26.50 34.25 \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  12.00   19.00   26.50   27.20   34.25   45.00 \n```\n\n\n:::\n:::\n\n\nQuantiles form the basis for many statistical procedures, including constructing confidence intervals and calculating p-values.\n\n## Bias and Variability\n\nTwo distinct types of error affect estimates:\n\n**Bias** is systematic error—the tendency for an estimator to consistently over- or underestimate the true parameter. An unbiased estimator has zero bias: its average value across all possible samples equals the true parameter.\n\n**Variability** is random error—the spread of estimates around their average value. Low variability means estimates cluster tightly together.\n\nThe ideal estimator has both low bias and low variability. Sometimes there is a tradeoff: a slightly biased estimator might have much lower variability, resulting in estimates that are closer to the truth on average.\n\nThe **mean squared error** (MSE) combines both sources of error:\n\n$$MSE = Bias^2 + Variance$$\n\n## The Bootstrap: Resampling for Estimation\n\nThe bootstrap, introduced by Bradley Efron in 1979, is a powerful resampling method for estimating standard errors and constructing confidence intervals when analytical formulas are unavailable or assumptions are questionable [@efron1979bootstrap].\n\nThe key insight is elegant: we can estimate the sampling distribution of a statistic by repeatedly resampling from our observed data. If our sample is representative of the population, then samples drawn from our sample (with replacement) should behave like samples drawn from the population.\n\n### The Bootstrap Algorithm\n\n1. Take a random sample with replacement from your data (same size as original)\n2. Calculate the statistic of interest on this resampled data\n3. Repeat steps 1-2 many times (typically 1000-10000)\n4. The distribution of bootstrap statistics approximates the sampling distribution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bootstrap estimation of the sampling distribution of the mean\nset.seed(123)\n\n# Our observed sample\noriginal_sample <- c(23, 31, 28, 35, 42, 29, 33, 27, 38, 31)\nn <- length(original_sample)\n\n# Bootstrap: resample with replacement\nn_bootstrap <- 5000\nbootstrap_means <- numeric(n_bootstrap)\n\nfor (i in 1:n_bootstrap) {\n  boot_sample <- sample(original_sample, size = n, replace = TRUE)\n  bootstrap_means[i] <- mean(boot_sample)\n}\n\n# Compare bootstrap distribution to observed statistics\nhist(bootstrap_means, breaks = 40, col = \"steelblue\",\n     main = \"Bootstrap Distribution of the Mean\",\n     xlab = \"Sample Mean\")\nabline(v = mean(original_sample), col = \"red\", lwd = 2)\nabline(v = quantile(bootstrap_means, c(0.025, 0.975)), col = \"darkgreen\", lwd = 2, lty = 2)\n```\n\n::: {.cell-output-display}\n![](10-sampling-estimation_files/figure-html/unnamed-chunk-12-1.png){width=768}\n:::\n\n```{.r .cell-code}\ncat(\"Original sample mean:\", mean(original_sample), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOriginal sample mean: 31.7 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Bootstrap SE:\", sd(bootstrap_means), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBootstrap SE: 1.635207 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"95% Bootstrap CI:\", quantile(bootstrap_means, c(0.025, 0.975)), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n95% Bootstrap CI: 28.7 35.0025 \n```\n\n\n:::\n:::\n\n\n### Bootstrap Confidence Intervals\n\nThe bootstrap provides several methods for constructing confidence intervals:\n\n**Percentile method**: Use the 2.5th and 97.5th percentiles of the bootstrap distribution as the 95% CI bounds. This is the simplest approach shown above.\n\n**Basic (reverse percentile) method**: Reflects the percentiles around the original estimate to correct for certain types of bias.\n\n**BCa (bias-corrected and accelerated)**: A more sophisticated method that adjusts for both bias and skewness in the bootstrap distribution. This is often preferred when the sampling distribution is not symmetric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Using the boot package for more sophisticated bootstrap CI\nlibrary(boot)\n\n# Define statistic function\nmean_stat <- function(data, indices) {\n  mean(data[indices])\n}\n\n# Run bootstrap\nboot_result <- boot(original_sample, mean_stat, R = 5000)\n\n# Different CI methods\nboot.ci(boot_result, type = c(\"perc\", \"basic\", \"bca\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\nBased on 5000 bootstrap replicates\n\nCALL : \nboot.ci(boot.out = boot_result, type = c(\"perc\", \"basic\", \"bca\"))\n\nIntervals : \nLevel      Basic              Percentile            BCa          \n95%   (28.3, 34.9 )   (28.5, 35.1 )   (28.5, 35.1 )  \nCalculations and Intervals on Original Scale\n```\n\n\n:::\n:::\n\n\n### When to Use the Bootstrap\n\nThe bootstrap is particularly valuable when:\n\n- The sampling distribution of your statistic is unknown or complex\n- Sample sizes are small and normality assumptions are questionable\n- You are estimating something other than a mean (e.g., median, correlation, regression coefficients)\n- Analytical formulas for standard errors do not exist\n\nHowever, the bootstrap has limitations. It assumes your sample is representative of the population and works poorly with very small samples (n < 10-15) or when estimating extreme quantiles.\n\n## Maximum Likelihood Estimation\n\n**Maximum likelihood estimation (MLE)** provides a principled framework for parameter estimation. The likelihood function measures how probable the observed data would be for different parameter values. MLE finds the parameter values that make the observed data most probable.\n\nFor a sample $x_1, x_2, \\ldots, x_n$ from a distribution with parameter $\\theta$, the likelihood function is:\n\n$$L(\\theta | x_1, \\ldots, x_n) = \\prod_{i=1}^{n} f(x_i | \\theta)$$\n\nwhere $f(x_i | \\theta)$ is the probability density (or mass) function. We typically work with the log-likelihood for computational convenience:\n\n$$\\ell(\\theta) = \\sum_{i=1}^{n} \\log f(x_i | \\theta)$$\n\nThe MLE $\\hat{\\theta}$ is the value that maximizes $\\ell(\\theta)$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# MLE example: estimating the rate parameter of an exponential distribution\nset.seed(42)\nexp_data <- rexp(100, rate = 0.5)  # True rate is 0.5\n\n# Log-likelihood function for exponential\nlog_likelihood <- function(rate, data) {\n  sum(dexp(data, rate = rate, log = TRUE))\n}\n\n# Find MLE\nrates <- seq(0.1, 1, by = 0.01)\nll_values <- sapply(rates, log_likelihood, data = exp_data)\n\n# Plot likelihood surface\nplot(rates, ll_values, type = \"l\", lwd = 2,\n     xlab = \"Rate parameter\", ylab = \"Log-likelihood\",\n     main = \"Log-likelihood for Exponential Rate\")\nabline(v = 1/mean(exp_data), col = \"red\", lwd = 2)  # MLE = 1/mean for exponential\n```\n\n::: {.cell-output-display}\n![](10-sampling-estimation_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncat(\"True rate: 0.5\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue rate: 0.5\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"MLE estimate:\", round(1/mean(exp_data), 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMLE estimate: 0.445 \n```\n\n\n:::\n:::\n\n\nMLEs have desirable properties: they are consistent (converge to true values as n increases) and asymptotically efficient (achieve the smallest possible variance for large samples).\n\n## Simulation-Based Understanding of Estimation\n\nSimulation provides powerful intuition for statistical concepts. By repeatedly sampling from known populations, we can directly observe sampling distributions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exploring properties of estimators through simulation\nset.seed(456)\n\n# True population parameters\npop_mean <- 50\npop_sd <- 10\n\n# Simulate many samples and compute estimates\nn_samples <- 2000\nsample_sizes <- c(5, 15, 50)\n\npar(mfrow = c(2, 3))\n\nfor (n in sample_sizes) {\n  # Collect sample means\n  sample_means <- replicate(n_samples, {\n    samp <- rnorm(n, mean = pop_mean, sd = pop_sd)\n    mean(samp)\n  })\n\n  # Plot distribution of sample means\n  hist(sample_means, breaks = 40, col = \"steelblue\",\n       main = paste(\"Sample Means (n =\", n, \")\"),\n       xlab = \"Sample Mean\", xlim = c(35, 65))\n  abline(v = pop_mean, col = \"red\", lwd = 2)\n\n  # Calculate actual SE vs theoretical\n  actual_se <- sd(sample_means)\n  theoretical_se <- pop_sd / sqrt(n)\n\n  legend(\"topright\", bty = \"n\", cex = 0.8,\n         legend = c(paste(\"Actual SE:\", round(actual_se, 2)),\n                    paste(\"Theoretical:\", round(theoretical_se, 2))))\n}\n\n# Now do the same for sample standard deviations\nfor (n in sample_sizes) {\n  # Collect sample SDs\n  sample_sds <- replicate(n_samples, {\n    samp <- rnorm(n, mean = pop_mean, sd = pop_sd)\n    sd(samp)\n  })\n\n  hist(sample_sds, breaks = 40, col = \"coral\",\n       main = paste(\"Sample SDs (n =\", n, \")\"),\n       xlab = \"Sample SD\")\n  abline(v = pop_sd, col = \"red\", lwd = 2)\n}\n```\n\n::: {.cell-output-display}\n![](10-sampling-estimation_files/figure-html/unnamed-chunk-15-1.png){width=864}\n:::\n:::\n\n\nThis simulation reveals several important facts:\n1. Sample means are unbiased (centered on the population mean)\n2. The spread of sample means decreases as $\\sqrt{n}$\n3. Sample standard deviations are slightly biased for small samples but become unbiased as n increases\n\n## Principles of Experimental Design\n\nGood statistical analysis cannot rescue a poorly designed study. The way you collect data fundamentally determines what conclusions you can draw. Understanding key design principles is essential for planning experiments that yield valid, interpretable results.\n\n### Randomization\n\n**Randomization** assigns subjects to treatment groups by chance, ensuring that treatment groups are comparable. Without randomization, systematic differences between groups (confounders) can bias results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Randomly assign 20 subjects to treatment or control\nset.seed(42)\nsubjects <- 1:20\ntreatment_group <- sample(subjects, size = 10)\ncontrol_group <- setdiff(subjects, treatment_group)\n\ncat(\"Treatment group:\", treatment_group, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTreatment group: 17 5 1 10 4 2 20 18 8 7 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Control group:\", control_group, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nControl group: 3 6 9 11 12 13 14 15 16 19 \n```\n\n\n:::\n:::\n\n\nRandomization provides the foundation for causal inference. Without it, we can only establish associations, not causation.\n\n### Controls\n\nEvery experiment needs **controls**—groups that differ from treatment groups only in the variable of interest:\n\n- **Negative control**: Receives no treatment; establishes baseline\n- **Positive control**: Receives a treatment known to work; confirms the experimental system is functioning\n- **Procedural control**: Receives all procedures except the active ingredient (e.g., sham surgery, vehicle-only injection)\n\nWithout proper controls, you cannot determine whether observed effects are due to your treatment or some other factor.\n\n### Blinding\n\n**Blinding** prevents knowledge of group assignment from influencing results:\n\n- **Single-blind**: Subjects do not know which treatment they receive\n- **Double-blind**: Neither subjects nor experimenters know group assignments\n- **Triple-blind**: Subjects, experimenters, and data analysts are all blinded\n\nBlinding prevents both placebo effects (subjects' expectations influencing outcomes) and experimenter bias (conscious or unconscious influence on measurements).\n\n### Replication\n\n**Replication** means having multiple independent observations in each treatment group. Replication is essential because it:\n\n- Provides estimates of variability\n- Enables statistical inference\n- Increases precision of estimates\n- Allows detection of real effects\n\nThe **unit of replication** must match the **unit of treatment**. If you treat tanks with different water temperatures and measure multiple fish per tank, your replicates are tanks, not fish.\n\n::: {.callout-warning}\n## Technical vs. Biological Replicates\n\n- **Technical replicates**: Repeated measurements of the same sample (e.g., running the same sample through a machine twice)\n- **Biological replicates**: Independent samples from different individuals or experimental units\n\nTechnical replicates measure precision of the measurement process. Biological replicates measure biological variability and enable inference to the population. Do not confuse them!\n:::\n\n### Blocking\n\n**Blocking** groups experimental units that are similar to each other, then applies all treatments within each block. This reduces variability by accounting for known sources of heterogeneity.\n\nCommon blocking factors:\n- Time (experimental batches, days)\n- Location (different incubators, growth chambers)\n- Individual (paired designs, repeated measures)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Randomized complete block design\n# 4 treatments applied within each of 3 blocks\nset.seed(123)\nblocks <- 1:3\ntreatments <- c(\"A\", \"B\", \"C\", \"D\")\n\ndesign <- expand.grid(Block = blocks, Treatment = treatments)\ndesign$Order <- NA\n\nfor (b in blocks) {\n  block_rows <- design$Block == b\n  design$Order[block_rows] <- sample(1:4)\n}\n\ndesign[order(design$Block, design$Order), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Block Treatment Order\n7      1         C     1\n10     1         D     2\n1      1         A     3\n4      1         B     4\n11     2         D     1\n5      2         B     2\n2      2         A     3\n8      2         C     4\n6      3         B     1\n9      3         C     2\n3      3         A     3\n12     3         D     4\n```\n\n\n:::\n:::\n\n\nBlocking is particularly valuable when blocks correspond to major sources of variation (e.g., different labs, experimental days, genetic backgrounds).\n\n### Sample Size Considerations\n\nDetermining appropriate sample size before collecting data is crucial. Too few samples waste resources by producing inconclusive results; too many waste resources by studying effects that were detectable with smaller samples.\n\nSample size depends on:\n- **Effect size**: The minimum meaningful difference you want to detect\n- **Variability**: The expected noise in your measurements\n- **Significance level ($\\alpha$)**: Usually 0.05\n- **Power**: Usually 0.80 (80% chance of detecting a real effect)\n\nPower analysis (covered in detail in a later chapter) formalizes these considerations.\n\n## Key Takeaways\n\nUnderstanding sampling distributions and estimation is fundamental to statistical inference. Key points to remember:\n\n1. Statistics vary from sample to sample; this variability is quantified by the standard error\n2. Larger samples give more precise estimates (smaller standard errors)\n3. Confidence intervals quantify uncertainty about parameter estimates\n4. The Central Limit Theorem explains why the normal distribution appears so frequently\n5. Both bias and variability affect the quality of estimates\n6. The bootstrap provides a flexible, computer-intensive approach to estimation when analytical methods are limited\n7. Maximum likelihood provides a principled framework for parameter estimation\n8. Good experimental design—randomization, controls, blinding, proper replication—is essential for valid inference\n\nThese concepts provide the foundation for hypothesis testing and the statistical inference methods we develop in subsequent chapters.\n\n## Additional Resources\n\n- @efron1979bootstrap - The original bootstrap paper, a landmark in modern statistics\n- @irizarry2019introduction - Excellent chapters on sampling and estimation with R examples\n",
    "supporting": [
      "10-sampling-estimation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}