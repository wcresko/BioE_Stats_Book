{
  "hash": "472b4e219f04f69efe13d2f7a91e5cd5",
  "result": {
    "engine": "knitr",
    "markdown": "# Unix and the Command Line {#sec-unix}\n\n\n::: {.cell}\n\n:::\n\n\n![](../images/w1_code.jpeg){fig-align=\"center\"}\n\n## What is Unix?\n\nUnix is a family of operating systems that originated at Bell Labs in 1969 and was released publicly in 1973. Its design philosophy emphasizes modularity—small programs that do one thing well and can be combined to accomplish complex tasks. This approach has proven remarkably durable, and Unix-based systems remain dominant in scientific computing, web servers, and high-performance computing environments.\n\nLinux is an open-source implementation of Unix that runs on everything from embedded devices to the world's fastest supercomputers. MacOS is built on a Unix foundation, which means Mac users have native access to Unix commands. Windows historically used a different approach, but recent versions include the Windows Subsystem for Linux (WSL), allowing Windows users to run Linux environments alongside their Windows applications.\n\nUnderstanding Unix is essential for modern data science. You will need it to access remote computing resources like supercomputer clusters, to run bioinformatics software that is only available through the command line, and to automate repetitive tasks. The skills you develop here will transfer across platforms and remain relevant throughout your career.\n\n## The Shell and Terminal\n\nThe shell is a program that interprets your commands and communicates with the operating system. When you type a command, the shell parses it, figures out what you want to do, and tells the operating system to do it. The results are then displayed back to you.\n\nBash (Bourne Again SHell) is the most common shell on Linux systems and was the default on MacOS until recently (MacOS now defaults to zsh, which is very similar). The shell runs inside a terminal application, which provides the window where you type commands and see output.\n\n![](../images/w1_shell.jpeg){fig-align=\"center\"}\n\nOn Mac, you can access the terminal by opening the Terminal app or a third-party alternative like iTerm2. On Linux, look for a Terminal application in your system menus. Windows users should install the Windows Subsystem for Linux following Microsoft's documentation, then access it through the Ubuntu app or similar.\n\nRStudio also includes a terminal pane, which can be convenient when you want shell access without leaving your R development environment.\n\n## Anatomy of a Shell Command\n\nShell commands follow a consistent structure. You type a command name, possibly followed by options that modify its behavior, and arguments that specify what the command should operate on. The shell waits at a prompt—typically `$` for regular users or `#` for administrators—indicating it is ready to accept input.\n\n![](../images/w1_shell_command.jpeg){fig-align=\"center\"}\n\nConsider the command `ls -l Documents`. Here, `ls` is the command (list directory contents), `-l` is an option (use long format), and `Documents` is the argument (the directory to list). Options usually begin with a dash and can often be combined: `ls -la` combines the `-l` (long format) and `-a` (show hidden files) options.\n\n## File System Organization\n\nUnix organizes files in a hierarchical structure of directories (folders) and files. The root directory, represented by a single forward slash `/`, sits at the top of this hierarchy and contains all other directories.\n\n![](../images/w1_file_structure.jpeg){fig-align=\"center\"}\n\nYour home directory is your personal workspace, typically located at `/Users/yourusername` on Mac or `/home/yourusername` on Linux. The tilde character `~` serves as a shorthand for your home directory, so `~/Documents` refers to the Documents folder in your home directory.\n\nEvery file and directory has a path—a specification of its location in the file system. Absolute paths start from the root directory and give the complete location, like `/Users/wcresko/Documents/data.csv`. Relative paths specify location relative to your current directory, so if you are in your home directory, `Documents/data.csv` refers to the same file.\n\n## Navigation Commands\n\nThe most fundamental navigation command is `pwd` (print working directory), which tells you where you currently are in the file system. This is often the first thing you type when opening a terminal to orient yourself.\n\n![](../images/w1_navigation_1.jpeg){fig-align=\"center\"}\n\n```bash\npwd\n```\n\nThe `ls` command lists the contents of a directory. Without arguments, it lists the current directory. With a path argument, it lists that location.\n\n```bash\nls                  # list current directory\nls Documents        # list the Documents folder\nls -l               # long format with details\nls -a               # include hidden files (starting with .)\nls -la              # combine long format and hidden files\nls -lS              # long format, sorted by size\n```\n\n![](../images/w1_navigation_2.jpeg){fig-align=\"center\"}\n\nThe `cd` command (change directory) moves you to a different location.\n\n```bash\ncd Documents        # move into Documents\ncd ..               # move up one level (parent directory)\ncd ~                # move to home directory\ncd /                # move to root directory\ncd -                # move to previous location\n```\n\n![](../images/w1_navigate.jpeg){fig-align=\"center\"}\n\n## Working with Files and Directories\n\nCreating new directories uses the `mkdir` command.\n\n```bash\nmkdir project_data\nmkdir -p analysis/results/figures  # create nested directories\n```\n\nThe `-p` flag tells `mkdir` to create parent directories as needed, which is useful for creating nested folder structures in one command.\n\nMoving and renaming files uses the `mv` command.\n\n```bash\nmv old_name.txt new_name.txt       # rename a file\nmv file.txt Documents/             # move file to Documents\nmv file.txt Documents/newname.txt  # move and rename\n```\n\nCopying files uses `cp`.\n\n```bash\ncp original.txt copy.txt           # copy a file\ncp -r folder/ backup/              # copy a directory recursively\n```\n\nRemoving files uses `rm`. Be careful with this command—there is no trash can or undo in the shell.\n\n```bash\nrm unwanted_file.txt               # remove a file\nrm -r unwanted_folder/             # remove a directory and contents\nrm -i file.txt                     # ask for confirmation before removing\n```\n\n## Viewing File Contents\n\nSeveral commands let you examine file contents without opening them in an editor.\n\nThe `cat` command displays the entire contents of a file.\n\n```bash\ncat data.txt\n```\n\nFor longer files, `head` and `tail` show the beginning and end.\n\n```bash\nhead data.csv          # first 10 lines\nhead -n 20 data.csv    # first 20 lines\ntail data.csv          # last 10 lines\ntail -f logfile.txt    # follow a file as it grows\n```\n\nThe `less` command opens an interactive viewer that lets you scroll through large files.\n\n```bash\nless large_data.txt\n```\n\nInside `less`, use arrow keys to scroll, `/` to search, and `q` to quit.\n\nThe `wc` command counts lines, words, and characters.\n\n```bash\nwc data.txt            # lines, words, characters\nwc -l data.txt         # just lines\n```\n\n## Getting Help\n\nUnix provides documentation through manual pages, accessible with the `man` command.\n\n```bash\nman ls                 # manual page for ls command\n```\n\nManual pages can be dense, but they are comprehensive. Use the spacebar to page through, `/` to search, and `q` to exit. Many commands also accept a `--help` flag that provides a shorter summary.\n\n```bash\nls --help\n```\n\nOf course, the internet provides extensive resources. When you encounter an unfamiliar command or error message, searching online often leads to helpful explanations and examples.\n\n## Pipes and Redirection\n\nOne of Unix's most powerful features is the ability to combine simple commands into complex pipelines. The pipe operator `|` sends the output of one command to another command as input.\n\n```bash\nls -l | head -n 5           # list files, show only first 5\ncat data.txt | wc -l        # count lines in file\n```\n\nRedirection operators send output to files instead of the screen.\n\n```bash\nls -l > file_list.txt       # write output to file (overwrite)\nls -l >> file_list.txt      # append output to file\n```\n\nThese features enable powerful text processing. Combined with tools like `grep` (search for patterns), `sort`, and `cut` (extract columns), you can accomplish sophisticated data manipulation with compact commands.\n\n```bash\ngrep \"gene\" data.txt                    # find lines containing \"gene\"\ngrep -c \"gene\" data.txt                 # count matching lines\nsort data.txt                           # sort lines alphabetically\nsort -n numbers.txt                     # sort numerically\ncut -f1,3 data.tsv                      # extract columns 1 and 3 from tab-separated file\n```\n\n## Connecting to Remote Systems\n\nThe `ssh` command (secure shell) lets you connect to remote computers.\n\n```bash\nssh username@server.university.edu\n```\n\nYou will use this to connect to computing clusters like Talapas for computationally intensive work. Once connected, you work in a shell environment on the remote system just as you would locally.\n\nThe `scp` command copies files between your computer and remote systems.\n\n```bash\nscp local_file.txt username@server.edu:~/destination/\nscp username@server.edu:~/remote_file.txt ./local_copy.txt\n```\n\n## Practice Exercises\n\nThe best way to learn command-line skills is through practice. Create a project folder structure for organizing your course work. Navigate through the file system and examine the contents of various directories. Create some text files and practice viewing, copying, moving, and removing them.\n\nTry combining commands with pipes. For example, you might list all files in a directory, filter for those with a particular extension, and count how many there are. Start simple and gradually build more complex pipelines as you become comfortable with the individual commands.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}