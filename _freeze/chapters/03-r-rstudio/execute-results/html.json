{
  "hash": "ac6a49bb177c3ccb0eebc5555376434f",
  "result": {
    "engine": "knitr",
    "markdown": "# R and RStudio {#sec-r-rstudio}\n\n\n::: {.cell}\n\n:::\n\n\n![](../images/RStudio_Screenshot.png){fig-align=\"center\"}\n\n## What is R?\n\nR is a computer programming language and environment especially useful for graphic visualization and statistical analysis of data. It is an offshoot of a language developed in 1976 at Bell Laboratories called S. R is an interpreted language, meaning that every time code is run it must be translated to machine language by the R interpreter, as opposed to being compiled prior to running. R is the premier computational platform for statistical analysis thanks to its GNU open-source status and countless packages contributed by diverse members of the scientific community.\n\n## Why R?\n\nR is a programming language designed specifically for statistical computing and graphics. Created in the early 1990s as an open-source implementation of the S language, R has become the lingua franca of statistical analysis in academia and is widely used in industry as well.\n\nSeveral features make R particularly well-suited for data analysis. It provides an extensive collection of statistical and graphical techniques built into the language. It is powerful, flexible, and completely free. It runs on Windows, Mac, and Linux, so your code will work across platforms. New capabilities are constantly being added through packages contributed by the community, with thousands of packages available for specialized analyses.\n\nR excels at reproducibility. You can keep your scripts to document exactly what analyses you performed. Unlike point-and-click software where actions leave no trace, R code provides a complete record of your analytical workflow. This record can be shared with collaborators, included in publications, and revisited years later when you need to remember how you produced a particular result.\n\nYou can write your own functions in R, extending the language to meet your specific needs. Extensive online help and active user communities mean that answers to most questions are a web search away. The RStudio integrated development environment makes working with R much more pleasant, especially for newcomers. And with tools like R Markdown and Quarto, you can embed your analyses in polished documents, presentations, websites, and books—this book itself was created with these tools.\n\n## Installing R and RStudio\n\nR must be installed before RStudio. Download R from [https://www.r-project.org](https://www.r-project.org), selecting the version appropriate for your operating system. Follow the installation instructions for your platform.\n\nRStudio is an integrated development environment (IDE) that makes working with R much easier. Download the free RStudio Desktop from [https://www.rstudio.com](https://www.rstudio.com). RStudio provides a console for running R commands, an editor for writing scripts, tools for viewing plots and data, and integration with version control systems.\n\nAfter installing both programs, launch RStudio. You will see a window divided into panes, each serving a different purpose. The console pane is where R commands are executed. The source pane is where you edit scripts and documents. The environment pane shows what objects currently exist in your R session. The files/plots/packages/help pane provides access to various utilities.\n\n## R Basics\n\nR evaluates expressions and returns results. You can use it as a calculator by typing arithmetic expressions at the console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n4 * 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n\n```{.r .cell-code}\n(4 + 3 * 2^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n:::\n\n\nNotice that R follows standard mathematical order of operations: exponentiation before multiplication and division, which come before addition and subtraction. Parentheses can override this ordering.\n\n## Variables and Assignment\n\nMore useful than evaluating isolated expressions is storing values in variables for later use. Variables are assigned using the `<-` operator (a less-than sign followed by a hyphen).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\nx * 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- x * 3\ny - 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\nVariable names must begin with a letter but can contain letters, numbers, periods, and underscores after the first character. R is case-sensitive, so `myVariable`, `MyVariable`, and `myvariable` are three different names. Choose descriptive names that make your code readable. It is good practice to avoid periods in variable names, as they have other functionality in related programming languages like Python.\n\n::: {.callout-warning}\n## Invalid Variable Names\nVariable names cannot begin with numbers or contain operators. The following will produce errors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3y <- 3    # cannot start with a number\n3*y <- 3   # cannot include operators\n```\n:::\n\n:::\n\n### Reserved Words\n\nR has **reserved words** that cannot be used as variable names because they have special meaning in the language:\n\n| Reserved Words | Purpose |\n|:---------------|:--------|\n| `if`, `else` | Conditional statements |\n| `for`, `while`, `repeat` | Loops |\n| `function` | Function definition |\n| `in`, `next`, `break` | Loop control |\n| `TRUE`, `FALSE` | Logical constants |\n| `NULL`, `NA`, `NaN`, `Inf` | Special values |\n\nR also has **semi-reserved names**—built-in functions and constants that you can technically overwrite but should avoid:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# These work but are dangerous:\nT <- 5       # Overwrites TRUE abbreviation\nc <- \"text\"  # Shadows the c() function\nmean <- 42   # Shadows mean()\n\n# If you accidentally overwrite something, remove it:\nrm(c)        # Restores access to c()\n```\n:::\n\n\n::: {.callout-warning}\n## Avoid Common Name Collisions\nNever name variables `T`, `F` (abbreviations for `TRUE`/`FALSE`), `c`, `t`, `mean`, `sum`, `data`, or `df`. These are commonly used R functions, and shadowing them leads to confusing errors.\n:::\n\nNote that when you assign a value to a variable, R does not print anything. To see a variable's value, type its name alone or use the `print()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- 100\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n:::\n\n\n## Understanding R Objects\n\nA fundamental principle of R is that **everything is an object**. Numbers, text, datasets, functions—all are stored as objects with specific properties. Understanding this helps you debug problems and write better code.\n\nEvery object has a **class** (which determines how functions treat it) and a **type** (its underlying storage mode). Use `class()` and `typeof()` to examine objects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Numbers are objects\nx <- 42\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Text strings are objects\nname <- \"Gene Expression\"\nclass(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Even functions are objects!\nclass(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n:::\n\n\nThe `str()` function (**str**ucture) provides a compact display of any object's structure—it is one of the most useful diagnostic tools in R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Examine a vector\nstr(c(1, 2, 3, 4, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n num [1:5] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Examine a data frame\nstr(head(iris))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t6 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1\n```\n\n\n:::\n:::\n\n\nWhen functions produce errors or unexpected results, checking the class of your objects is often the first step toward understanding what went wrong.\n\n## Functions\n\nFunctions are the workhorses of R. A function takes inputs (called arguments), performs some operation, and returns an output. R has many built-in functions, and packages provide thousands more.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.302585\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt(16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nexp(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.718282\n```\n\n\n:::\n:::\n\n\nFunctions are called by typing their name followed by parentheses containing their arguments. Many functions accept multiple arguments, separated by commas. Arguments can be specified by position or by name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(3.14159, digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.14\n```\n\n\n:::\n\n```{.r .cell-code}\nround(3.14159, 2)  # same result, argument specified by position\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.14\n```\n\n\n:::\n:::\n\n\nTo learn about a function, use the help system. Type `?functionname` or `help(functionname)` to open the documentation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?round\nhelp(sqrt)\n```\n:::\n\n\n## Vectors\n\nThe fundamental data structure in R is the vector, an ordered collection of values of the same type. You create vectors using the `c()` function (for concatenate or combine).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(1, 2, 3, 4, 5)\nnumbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nnames <- c(\"Alice\", \"Bob\", \"Carol\")\nnames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\" \"Bob\"   \"Carol\"\n```\n\n\n:::\n:::\n\n\nMany operations in R are vectorized, meaning they operate on entire vectors at once rather than requiring you to loop through elements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers + 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 12 13 14 15\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  9 16 25\n```\n\n\n:::\n:::\n\n\nYou can access individual elements using square brackets with an index (R uses 1-based indexing, so the first element is at position 1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers[c(1, 3, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 5\n```\n\n\n:::\n:::\n\n\n## Creating Sequences\n\nR provides convenient functions for creating regular sequences.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(0, 10, by = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0  2  4  6  8 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(0, 1, length.out = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.00 0.25 0.50 0.75 1.00\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(1, times = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 1 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(c(1, 2), times = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 1 2 1 2\n```\n\n\n:::\n:::\n\n\n## Generating Random Numbers\n\nR can generate random numbers from various probability distributions, which is invaluable for simulation and understanding statistical concepts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Draw 1000 values from a normal distribution with mean 0 and SD 10\nx <- rnorm(1000, mean = 0, sd = 10)\nhist(x)\n```\n\n::: {.cell-output-display}\n![](03-r-rstudio_files/figure-html/unnamed-chunk-16-1.png){width=576}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Draw from a binomial distribution: 1000 experiments, 20 trials each, p=0.5\nheads <- rbinom(n = 1000, size = 20, prob = 0.5)\nhist(heads)\n```\n\n::: {.cell-output-display}\n![](03-r-rstudio_files/figure-html/unnamed-chunk-17-1.png){width=576}\n:::\n:::\n\n\nThe `set.seed()` function allows you to make random simulations reproducible by initializing the random number generator to a known state.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\nrnorm(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.3709584 -0.5646982  0.3631284  0.6328626  0.4042683\n```\n\n\n:::\n\n```{.r .cell-code}\nset.seed(42)  # same seed produces same \"random\" numbers\nrnorm(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.3709584 -0.5646982  0.3631284  0.6328626  0.4042683\n```\n\n\n:::\n:::\n\n\n## Data Frames\n\nData frames are R's structure for tabular data—rows of observations and columns of variables. Each column can contain a different type of data (numeric, character, logical), but all values within a column must be the same type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame from vectors\nhydrogel_concentration <- factor(c(\"low\", \"high\", \"high\", \"high\", \n                                    \"medium\", \"medium\", \"medium\", \"low\"))\ncompression <- c(3.4, 3.4, 8.4, 3, 5.6, 8.1, 8.3, 4.5)\nconductivity <- c(0, 9.2, 3.8, 5, 5.6, 4.1, 7.1, 5.3)\n\nmydata <- data.frame(hydrogel_concentration, compression, conductivity)\nmydata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  hydrogel_concentration compression conductivity\n1                    low         3.4          0.0\n2                   high         3.4          9.2\n3                   high         8.4          3.8\n4                   high         3.0          5.0\n5                 medium         5.6          5.6\n6                 medium         8.1          4.1\n7                 medium         8.3          7.1\n8                    low         4.5          5.3\n```\n\n\n:::\n:::\n\n\nAccess columns using the `$` operator or square brackets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmydata$compression\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.4 3.4 8.4 3.0 5.6 8.1 8.3 4.5\n```\n\n\n:::\n\n```{.r .cell-code}\nmydata[, 2]  # second column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.4 3.4 8.4 3.0 5.6 8.1 8.3 4.5\n```\n\n\n:::\n\n```{.r .cell-code}\nmydata[1, ]  # first row\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  hydrogel_concentration compression conductivity\n1                    low         3.4            0\n```\n\n\n:::\n\n```{.r .cell-code}\nmydata[1, 2] # first row, second column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.4\n```\n\n\n:::\n:::\n\n\n## Reading and Writing Data\n\nReal analyses typically begin by reading data from external files. R provides functions for various file formats.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read comma-separated values\ndata <- read.csv(\"mydata.csv\")\n\n# Read tab-separated values\ndata <- read.table(\"mydata.txt\", header = TRUE, sep = \"\\t\")\n\n# Read Excel files (requires readxl package)\nlibrary(readxl)\ndata <- read_excel(\"mydata.xlsx\")\n```\n:::\n\n\nSimilarly, you can write data to files.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(mydata, \"output.csv\", row.names = FALSE)\nwrite.table(mydata, \"output.txt\", sep = \"\\t\", row.names = FALSE)\n```\n:::\n\n\n## Basic Plotting\n\nR has extensive graphics capabilities. The base `plot()` function creates scatterplots and other basic visualizations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\ny <- x^2\nplot(x, y, \n     xlab = \"X values\", \n     ylab = \"Y squared\",\n     main = \"A Simple Plot\",\n     col = \"blue\",\n     pch = 19)\n```\n\n::: {.cell-output-display}\n![](03-r-rstudio_files/figure-html/unnamed-chunk-23-1.png){width=576}\n:::\n:::\n\n\nHistograms visualize the distribution of a single variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- rnorm(1000)\nhist(data, breaks = 30, col = \"lightblue\", main = \"Normal Distribution\")\n```\n\n::: {.cell-output-display}\n![](03-r-rstudio_files/figure-html/unnamed-chunk-24-1.png){width=576}\n:::\n:::\n\n\nBoxplots compare distributions across groups.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(compression ~ hydrogel_concentration, data = mydata,\n        xlab = \"Concentration\", ylab = \"Compression\")\n```\n\n::: {.cell-output-display}\n![](03-r-rstudio_files/figure-html/unnamed-chunk-25-1.png){width=576}\n:::\n:::\n\n\nWe will explore the more sophisticated `ggplot2` package for graphics in a later chapter.\n\n## Scripts and Reproducibility\n\nWhile you can type commands directly at the console, for anything beyond simple explorations you should write scripts—text files containing R commands that can be saved, edited, and rerun.\n\nIn RStudio, create a new script with File > New File > R Script. Type your commands in the script editor, and run them by placing your cursor on a line and pressing Ctrl+Enter (Cmd+Enter on Mac) or by selecting code and clicking Run.\n\nScripts should be self-contained, including all the commands needed to reproduce your analysis from start to finish. Begin scripts by loading required packages, then reading data, then performing analyses. Add comments (lines beginning with `#`) to explain what your code does and why.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Analysis of hydrogel mechanical properties\n# Author: Your Name\n# Date: 2025-04-01\n\n# Load required packages\nlibrary(tidyverse)\n\n# Read data\ndata <- read.csv(\"hydrogel_data.csv\")\n\n# Calculate summary statistics\nsummary(data)\n\n# Create visualization\nggplot(data, aes(x = concentration, y = compression)) +\n  geom_boxplot()\n```\n:::\n\n\n## Getting Help\n\nWhen you encounter problems, R provides several resources. The `?` operator opens documentation for functions. The `help.search()` function searches the help system for topics. The `example()` function runs examples from a function's documentation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?mean\nhelp.search(\"regression\")\nexample(plot)\n```\n:::\n\n\nBeyond R's built-in help, the internet offers vast resources. Stack Overflow has answers to almost any R question you can imagine. Package vignettes provide tutorials for specific packages. The RStudio community forums are welcoming to beginners.\n\nWhen asking for help online, provide a minimal reproducible example—the smallest piece of code that demonstrates your problem, including sample data. This makes it much easier for others to understand and solve your issue.\n\n## Data Types in R\n\nR has several fundamental data types that you will work with frequently.\n\n### Character Strings\n\nAssignments and operations can be performed on characters as well as numbers. Characters need to be set off by quotation marks to differentiate them from numeric objects or variable names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"I Love\"\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I Love\"\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- \"Biostatistics\"\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Biostatistics\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Combine strings using c()\nz <- c(x, y)\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I Love\"        \"Biostatistics\"\n```\n\n\n:::\n:::\n\n\nThe variable `z` is now a vector of character objects. Note that we are overwriting our previous numeric assignments—a good general rule is to use descriptive, unique names for each variable.\n\n### Factors\n\nSometimes we would like to treat character objects as if they were categorical units for subsequent calculations. These are called factors, and we can convert a character vector to factor class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz_factor <- as.factor(z)\nprint(z_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] I Love        Biostatistics\nLevels: Biostatistics I Love\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(z_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\nNote that factor levels are reported alphabetically. The `class()` function tells us what type of object we are working with—it is one of the most important diagnostic tools in R. Often you can debug your code simply by checking and changing the class of an object.\n\nFactors are especially important for statistical analyses where we might want to calculate the mean or variance for different experimental treatments. In that case, the treatments would be coded as different levels of a factor.\n\n### Missing Values (NA)\n\nR uses special values to represent missing or undefined data. The most common is `NA`, which stands for \"Not Available.\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n`NA` is a logical data type and is distinct from the character string \"NA\", the numeric 0, or an empty string. It is also a reserved word and cannot be used as a variable name.\n\nAny instance of a blank entry in your data file will be read into R as `NA`. Many functions in R will not work by default if passed any `NA` values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum <- c(0, 1, 2, NA, 4)\nmean(num)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# Use na.rm = TRUE to ignore missing values\nmean(num, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.75\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check for missing values\nis.na(num)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n### Floating-Point Precision\n\nA common source of confusion involves floating-point arithmetic. Computers represent decimal numbers with limited precision, which can lead to unexpected results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This seems wrong, but is due to how computers store decimals\n0.1 + 0.2 == 0.3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# The actual values differ slightly\nprint(0.1 + 0.2, digits = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.30000000000000004441\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(0.3, digits = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2999999999999999889\n```\n\n\n:::\n:::\n\n\nNever use `==` to compare floating-point numbers directly. Instead, use `all.equal()` which checks if values are \"nearly equal\" within a small tolerance:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Safe comparison for floating-point numbers\nall.equal(0.1 + 0.2, 0.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Use isTRUE() if you need a logical result\nisTRUE(all.equal(0.1 + 0.2, 0.3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nThe tidyverse provides `dplyr::near()` as a convenient alternative, especially when filtering data frames:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Works well in filter operations\nlibrary(dplyr)\ndata |> filter(near(value, target_value))\n```\n:::\n\n\n::: {.callout-warning}\n## Floating-Point Comparisons\nAlways use `all.equal()` or `near()` instead of `==` when comparing decimal calculations. This is a common source of bugs in data analysis code.\n:::\n\n## More on Vectors\n\n### Indexing Vectors\n\nIsolating specific elements from vectors is called indexing. R uses 1-based indexing with square brackets `[]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(10, 20, 30, 40, 50, 100, 200)\n\n# First element\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# Third element\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30\n```\n\n\n:::\n\n```{.r .cell-code}\n# Series of consecutive elements\nx[1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30 40\n```\n\n\n:::\n\n```{.r .cell-code}\n# Last four elements\nx[4:7]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  40  50 100 200\n```\n\n\n:::\n\n```{.r .cell-code}\n# Non-consecutive elements using c()\nx[c(1:3, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30 50\n```\n\n\n:::\n\n```{.r .cell-code}\n# All elements EXCEPT the first two\nx[-c(1:2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  30  40  50 100 200\n```\n\n\n:::\n:::\n\n\n### Useful Functions for Vectors\n\n**Functions that provide information about vectors:**\n\n- `head()`: returns the first elements of an object\n- `tail()`: returns the last elements of an object\n- `length()`: returns the number of elements in a vector\n- `class()`: returns the class of elements in a vector\n\n**Functions that modify or generate vectors:**\n\n- `sort()`: returns a sorted vector\n- `seq()`: creates a sequence of values\n- `rep()`: repeats values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 1 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(\"treatment\", 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"treatment\" \"treatment\" \"treatment\" \"treatment\" \"treatment\"\n```\n\n\n:::\n:::\n\n\n**Functions for random sampling:**\n\n- `sample()`: randomly selects elements from a vector\n- `rnorm()`: draws values from a normal distribution\n- `rbinom()`: draws values from a binomial distribution\n- `set.seed()`: sets the random number generator seed for reproducibility\n\n**Functions to change data types:**\n\n- `as.numeric()`: converts to numeric class\n- `as.factor()`: converts to factor class\n- `as.character()`: converts to character class\n\n## Lists\n\nLists in R are aggregates of different objects that can be mixed types and different lengths.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec1 <- c(10, 20, 30, 40, 50, 100, 200)\nvec2 <- c(\"happy\", \"sad\", \"grumpy\")\nvec3 <- factor(c(\"high\", \"low\"))\n\nmylist <- list(vec1, vec2, vec3)\nprint(mylist)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1]  10  20  30  40  50 100 200\n\n[[2]]\n[1] \"happy\"  \"sad\"    \"grumpy\"\n\n[[3]]\n[1] high low \nLevels: high low\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(mylist)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(mylist)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ : num [1:7] 10 20 30 40 50 100 200\n $ : chr [1:3] \"happy\" \"sad\" \"grumpy\"\n $ : Factor w/ 2 levels \"high\",\"low\": 1 2\n```\n\n\n:::\n:::\n\n\nElements of lists are indexed with double square brackets `[[]]`. To access the second element of `mylist`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"happy\"  \"sad\"    \"grumpy\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# The second item of the second element\nmylist[[2]][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"sad\"\n```\n\n\n:::\n:::\n\n\nThe `str()` function (for \"structure\") is extremely useful for understanding complex R objects.\n\n## Matrices\n\nMatrices in R are two-dimensional arrays where all elements must be the same type. They are indexed by `[row, column]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a 3x3 matrix\nmatrix(1:9, nrow = 3, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n:::\n\n\nUseful matrix functions include:\n\n- `dim()`: returns the dimensions (rows and columns)\n- `t()`: transposes a matrix (swaps rows and columns)\n- `cbind()`: combines columns\n- `rbind()`: combines rows\n\n## Installing and Using Packages\n\nBase R includes many useful functions, but the real power comes from packages—collections of functions contributed by the community. Packages are distributed via the Comprehensive R Archive Network (CRAN).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install a package (only need to do once)\ninstall.packages(\"name_of_package\")\n\n# Check if package is installed\ninstalled.packages(\"name_of_package\")\n\n# Load package for use (needed each session)\nlibrary(name_of_package)\n```\n:::\n\n\nNote that `install.packages()` requires the package name in quotation marks, while `library()` does not.\n\n### Namespace Conflicts\n\nWhen you load multiple packages, function names can collide. If two packages define a function with the same name, the most recently loaded package \"wins,\" and its version masks the earlier one. R warns you when this happens:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n# Attaching package: 'dplyr'\n# The following objects are masked from 'package:stats':\n#     filter, lag\n```\n:::\n\n\nThis message indicates that dplyr's `filter()` and `lag()` functions are now masking the base R functions with those names. If you need the masked version, use the package prefix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use dplyr's filter (now the default after loading dplyr)\ndata |> filter(x > 5)\n\n# Explicitly use base R's filter\nstats::filter(x, method = \"convolution\")\n\n# You can use the prefix even without loading a package\nstringr::str_detect(text, \"pattern\")\n```\n:::\n\n\nCommon conflicts occur between:\n\n- `dplyr::filter()` and `stats::filter()`\n- `dplyr::lag()` and `stats::lag()`\n- `dplyr::select()` and `MASS::select()`\n\n::: {.callout-tip}\n## Avoiding Conflicts\nThe `::` notation explicitly specifies which package's function to use. When writing scripts, it is good practice to use `package::function()` for functions that commonly conflict, making your code's behavior explicit and predictable.\n:::\n\n## The Split-Apply-Combine Approach\n\nA common pattern in data analysis is to split data by groups, apply a function to each group, and combine the results. R provides several functions for this workflow.\n\n### The replicate() Function\n\nRepeats an expression multiple times and collects the results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Shuffle integers 1-10 five times\nreplicate(5, sample(1:10, size = 10, replace = FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3] [,4] [,5]\n [1,]    3    9    9    3    5\n [2,]    1    2   10    8    4\n [3,]    8    3    3    6    9\n [4,]    9    6    4    9    1\n [5,]   10    5    2    4   10\n [6,]    7    4    1    7    7\n [7,]    4    1    5    5    6\n [8,]    5   10    8   10    2\n [9,]    6    8    6    2    8\n[10,]    2    7    7    1    3\n```\n\n\n:::\n:::\n\n\n### The apply() Family\n\nThe `apply()` function applies a function to rows or columns of a matrix or data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create sample matrix\nm <- matrix(1:12, nrow = 3, ncol = 4)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n\n\n:::\n\n```{.r .cell-code}\n# Sum across rows (MARGIN = 1)\napply(m, 1, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22 26 30\n```\n\n\n:::\n\n```{.r .cell-code}\n# Sum across columns (MARGIN = 2)\napply(m, 2, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6 15 24 33\n```\n\n\n:::\n:::\n\n\n### The tapply() Function\n\nApplies a function to subsets of a vector, grouped by a factor:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Find maximum petal length for each species\ntapply(iris$Petal.Length, iris$Species, max)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    setosa versicolor  virginica \n       1.9        5.1        6.9 \n```\n\n\n:::\n:::\n\n\n### The aggregate() Function\n\nSummarizes multiple variables by groups:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mean of each variable by species\naggregate(iris[, 1:4], by = list(Species = iris$Species), FUN = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa        5.006       3.428        1.462       0.246\n2 versicolor        5.936       2.770        4.260       1.326\n3  virginica        6.588       2.974        5.552       2.026\n```\n\n\n:::\n:::\n\n\n## Conditional Statements with ifelse()\n\nThe `ifelse()` function provides vectorized conditional logic. The first argument is a logical test, the second is the value if TRUE, and the third is the value if FALSE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a character vector\ntreatment <- c(rep(\"treatment\", 5), rep(\"control\", 3),\n               rep(\"treatment\", 4), rep(\"control\", 6))\n\n# Assign colors based on treatment\ncolors <- ifelse(treatment == \"treatment\", \"red\", \"blue\")\nprint(colors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"red\"  \"red\"  \"red\"  \"red\"  \"red\"  \"blue\" \"blue\" \"blue\" \"red\"  \"red\" \n[11] \"red\"  \"red\"  \"blue\" \"blue\" \"blue\" \"blue\" \"blue\" \"blue\"\n```\n\n\n:::\n:::\n\n\n## For Loops\n\nFor loops iterate through a sequence, executing code for each value. However, R is vectorized, so many operations that would require loops in other languages can be done more efficiently without them.\n\nWhen loops are necessary, pre-allocate output objects for better performance:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pre-allocate a numeric vector\nresults <- numeric(5)\n\nfor (i in 1:5) {\n  results[i] <- i^2\n}\nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  9 16 25\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\n## Avoiding Loops\nBefore writing a loop, consider whether the task can be accomplished with vectorized operations or the apply family of functions. These approaches are often faster and more readable.\n:::\n\n## More on Plotting\n\n### Customizing Plots with par()\n\nMany plotting parameters are controlled by the `par()` function. Understanding `par()` dramatically increases your plotting capabilities.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create multiple panels\npar(mfrow = c(1, 2))  # 1 row, 2 columns\n\nseq_1 <- seq(0, 10, by = 0.1)\nseq_2 <- seq(10, 0, by = -0.1)\n\nplot(seq_1, xlab = \"Index\", ylab = \"Value\", type = \"p\", col = \"red\",\n     main = \"Increasing Sequence\")\nplot(seq_2, xlab = \"Index\", ylab = \"Value\", type = \"l\", col = \"blue\",\n     main = \"Decreasing Sequence\")\n```\n\n::: {.cell-output-display}\n![](03-r-rstudio_files/figure-html/unnamed-chunk-49-1.png){width=768}\n:::\n:::\n\n\n### Vectorized Graphical Parameters\n\nGraphical parameters like `col`, `pch` (point character), and `cex` (character expansion) are vectorized:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_1 <- seq(0, 10, by = 0.1)\nseq_2 <- seq(10, 0, by = -0.1)\n\n# First 10 points blue, rest red\ncolors <- c(rep(\"blue\", 10), rep(\"red\", 91))\n\nplot(seq_1, seq_2, xlab = \"Sequence 1\", ylab = \"Sequence 2\",\n     col = colors, pch = 19,\n     main = \"Two-Color Scatterplot\")\n```\n\n::: {.cell-output-display}\n![](03-r-rstudio_files/figure-html/unnamed-chunk-50-1.png){width=576}\n:::\n:::\n\n\n### Useful Plotting Arguments\n\nKey arguments for `plot()` and related functions:\n\n- `main`: plot title\n- `xlab`, `ylab`: axis labels\n- `xlim`, `ylim`: axis limits\n- `col`: color\n- `pch`: point character (0-25)\n- `cex`: character/point size multiplier\n- `lwd`: line width\n- `type`: \"p\" for points, \"l\" for lines, \"b\" for both\n\n## Introduction to R Markdown\n\nR Markdown combines R code with formatted text to create reproducible documents. Files have the `.Rmd` extension and can be rendered (\"knitted\") to HTML, PDF, or Word.\n\n### Getting Started\n\nInstall the `rmarkdown` package, then in RStudio: File → New File → R Markdown.\n\n### Basic Formatting\n\n```\n## Section Header\n### Subsection Header\n\nText can be *italicized* or **bolded** or ***both***.\n\nLinks: [Link Text](https://example.com)\n```\n\n### Code Chunks\n\nR code is placed in code chunks delimited by three backticks:\n\n````\n```{{r}}\nseq(1, 10, 1)\n```\n````\n\nChunk options control whether code is evaluated (`eval`), displayed (`echo`), and more:\n\n````\n```{{r, eval = TRUE, echo = TRUE}}\nseq(1, 10, 1)\n```\n````\n\n### Knitting\n\nClick the \"Knit\" button in RStudio to render your document. Start with HTML output, which has the fewest dependencies.\n\n::: {.callout-note}\n## Learning More\nFor comprehensive R Markdown documentation, see the [R Markdown introduction](https://rmarkdown.rstudio.com/articles_intro.html) and [R Markdown cheat sheet](https://rmarkdown.rstudio.com/lesson-15.html).\n:::\n\n## Practice Exercises\n\nFor hands-on practice with the concepts covered in this chapter, see @sec-ex-r in the Practice Exercises appendix. The exercises include:\n\n- Exploring the RStudio environment\n- Basic mathematics and variable assignment\n- Working with vectors, factors, and data frames\n- Creating visualizations\n- Data import and export\n\n## Additional Resources\n\n- @logan2010biostatistical - A comprehensive introduction to R for statistical analysis\n- [A Primer for Computational Biology](http://library.open.oregonstate.edu/computationalbiology/) - Free online textbook by S.T. O'Neil\n- [R Colors Reference](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) - Visual guide to R colors\n- [Introduction to Colors in R](https://www.stat.ubc.ca/~jenny/STAT545A/block14_colors.html) - Tutorial on using colors effectively\n",
    "supporting": [
      "03-r-rstudio_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}