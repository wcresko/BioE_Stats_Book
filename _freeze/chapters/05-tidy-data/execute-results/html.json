{
  "hash": "f343fd2ff8db2c44596fdcb6f6468005",
  "result": {
    "engine": "knitr",
    "markdown": "# Tidy Data and Data Wrangling {#sec-tidy-data}\n\n\n::: {.cell}\n\n:::\n\n\n![](../images/week_01.005.jpeg){fig-align=\"center\"}\n\n## What is Tidy Data?\n\nData comes in many shapes, and not all shapes are equally convenient for analysis. The concept of \"tidy data\" provides a standard way to organize data that works well with R and makes many analyses straightforward. In tidy data, each variable forms a column, each observation forms a row, and each type of observational unit forms a table.\n\n![](../images/week_01.006.jpeg){fig-align=\"center\"}\n\nThis structure might seem obvious, but real-world data rarely arrives in tidy form. Spreadsheets often encode information in column names, spread a single variable across multiple columns, or combine multiple variables in a single column. Data wrangling is the process of transforming messy data into tidy data.\n\n## Rules of Thumb for Data Organization\n\nWhether you are creating a new dataset or cleaning an existing one, following these principles will save you time and frustration.\n\nStore a copy of your data in nonproprietary formats like plain text CSV files. Proprietary formats can become unreadable as software changes. Keep an uncorrected copy of your original data separate from any cleaned or processed versions. Use descriptive names for files and variables that convey meaning without requiring external documentation. Include a header row with variable names. Maintain metadata—a data dictionary explaining what each variable means, how it was measured, and what units it uses.\n\nWhen you add new observations, add rows. When you add new variables, add columns. A column should contain only one data type—don't mix numbers and text in the same column. Dates should be in a consistent format. Missing values should be represented consistently, typically as empty cells or `NA` in R.\n\n## Types of Data\n\nUnderstanding the types of data you are working with guides how you analyze them.\n\n**Categorical data** classify observations into groups. Nominal categorical data have no inherent order—for example, species names, treatment groups, or colors. Ordinal categorical data have a meaningful order—ratings like \"low,\" \"medium,\" and \"high,\" or educational levels. In R, categorical data are often represented as factors, which store both the values and the set of possible levels.\n\n**Quantitative data** are numerical measurements. Interval data have meaningful differences between values but no true zero point—temperature in Celsius, where 0° does not mean \"no temperature.\" Ratio data have a true zero and meaningful ratios—mass, length, counts, where zero means \"none\" and twice as much is twice as much.\n\n| Categorical | | Quantitative | |\n|:--:|:--:|:--:|:--:|\n| Ordinal | Nominal | Ratio | Interval |\n| small, medium, large | apples, oranges | kilograms, dollars | temperature, calendar year |\n| ordered character | character | numeric | integer |\n\n## The Tidyverse\n\nThe tidyverse is a collection of R packages designed for data science. These packages share a common philosophy and are designed to work together seamlessly. The core tidyverse packages include `ggplot2` for visualization, `dplyr` for data manipulation, `tidyr` for reshaping data, `readr` for reading data files, and several others.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nLoading the tidyverse loads all core packages at once. The message shows which packages are attached and notes any functions that conflict with base R or other packages.\n\n![](../images/week_3.011.jpeg){fig-align=\"center\"}\n\n## Tibbles\n\nTibbles are the tidyverse's enhanced data frames. They print more informatively, showing only the first few rows and as many columns as fit on screen, along with the dimensions and column types.\n\n![](../images/week_3.012.jpeg){fig-align=\"center\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a tibble\nmy_tibble <- tibble(\n  name = c(\"Alice\", \"Bob\", \"Carol\"),\n  score = c(85, 92, 78),\n  passed = c(TRUE, TRUE, TRUE)\n)\nmy_tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  name  score passed\n  <chr> <dbl> <lgl> \n1 Alice    85 TRUE  \n2 Bob      92 TRUE  \n3 Carol    78 TRUE  \n```\n\n\n:::\n:::\n\n\nThe column types are shown below the column names: `<chr>` for character, `<dbl>` for double (numeric), and `<lgl>` for logical.\n\n## Key dplyr Verbs\n\nThe `dplyr` package provides a grammar for data manipulation. Five key verbs handle most data manipulation tasks.\n\n### filter(): Subset Rows\n\n`filter()` selects rows that meet specified conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Flights in November or December\nfilter(flights, month == 11 | month == 12)\n\n# Flights with arrival delay greater than 2 hours\nfilter(flights, arr_delay > 120)\n```\n:::\n\n\nConditions use comparison operators: `==` (equals), `!=` (not equals), `<`, `>`, `<=`, `>=`. Combine conditions with `&` (and) and `|` (or). The `%in%` operator checks membership in a set.\n\n### select(): Choose Columns\n\n`select()` picks columns by name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select specific columns\nselect(flights, year, month, day)\n\n# Select a range of columns\nselect(flights, year:day)\n\n# Drop columns\nselect(flights, -year, -month)\n```\n:::\n\n\n### arrange(): Sort Rows\n\n`arrange()` reorders rows by column values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sort by year, then month, then day\narrange(flights, year, month, day)\n\n# Sort in descending order\narrange(flights, desc(dep_delay))\n```\n:::\n\n\n### mutate(): Create New Columns\n\n`mutate()` adds new columns that are functions of existing columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(flights,\n  gain = arr_delay - dep_delay,\n  hours = air_time / 60,\n  gain_per_hour = gain / hours\n)\n```\n:::\n\n\n### summarize(): Aggregate Data\n\n`summarize()` collapses multiple rows into summary values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize(flights, \n  mean_delay = mean(dep_delay, na.rm = TRUE),\n  n = n()\n)\n```\n:::\n\n\nThe `na.rm = TRUE` argument tells `mean()` to ignore missing values. The `n()` function counts rows.\n\n## Grouping with group_by()\n\nThe real power of `summarize()` emerges when combined with `group_by()`, which splits data into groups for separate analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by destination, then summarize\nby_dest <- group_by(flights, dest)\nsummarize(by_dest, \n  count = n(),\n  mean_delay = mean(arr_delay, na.rm = TRUE)\n)\n```\n:::\n\n\nThis calculates summary statistics separately for each destination.\n\n## The Pipe Operator\n\nChaining multiple operations together can become unwieldy with nested function calls. The pipe operator `|>` (or the tidyverse's `%>%`) passes the result of one operation as the first argument of the next, allowing you to read operations left-to-right, top-to-bottom.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Without pipe: nested and hard to read\nsummarize(group_by(filter(flights, !is.na(arr_delay)), dest), \n          mean_delay = mean(arr_delay))\n\n# With pipe: clear sequence of operations\nflights |>\n  filter(!is.na(arr_delay)) |>\n  group_by(dest) |>\n  summarize(mean_delay = mean(arr_delay))\n```\n:::\n\n\nRead the pipe as \"then\"—take flights, then filter, then group, then summarize.\n\n![](../images/week_3.015.jpeg){fig-align=\"center\"}\n\n## Handling Missing Values\n\nMissing values are a fact of life in real data. In R, missing values are represented as `NA`. Most operations involving `NA` return `NA`, which can cause problems if you are not careful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, NA, 4)\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.333333\n```\n\n\n:::\n:::\n\n\nCheck for missing values with `is.na()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(is.na(x))  # count missing values\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\nFilter out missing values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[!is.na(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 4\n```\n\n\n:::\n:::\n\n\nOr use tidyr functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove rows with any missing values\ndrop_na(data)\n\n# Remove rows with missing values in specific columns\ndrop_na(data, column_name)\n```\n:::\n\n\n## Reshaping Data\n\nSometimes data is not in the right shape for your analysis. The `tidyr` package provides functions to reshape data.\n\n`pivot_longer()` takes wide data (variables spread across columns) and makes it long (variables stacked in rows). `pivot_wider()` does the reverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: wide data\nwide_data <- tibble(\n  sample = c(\"A\", \"B\", \"C\"),\n  treatment_1 = c(10, 15, 12),\n  treatment_2 = c(8, 14, 11)\n)\nwide_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  sample treatment_1 treatment_2\n  <chr>        <dbl>       <dbl>\n1 A               10           8\n2 B               15          14\n3 C               12          11\n```\n\n\n:::\n\n```{.r .cell-code}\n# Convert to long format\nlong_data <- wide_data |>\n  pivot_longer(\n    cols = starts_with(\"treatment\"),\n    names_to = \"treatment\",\n    values_to = \"response\"\n  )\nlong_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  sample treatment   response\n  <chr>  <chr>          <dbl>\n1 A      treatment_1       10\n2 A      treatment_2        8\n3 B      treatment_1       15\n4 B      treatment_2       14\n5 C      treatment_1       12\n6 C      treatment_2       11\n```\n\n\n:::\n:::\n\n\n## Joining Data\n\nOften data comes in multiple tables that need to be combined. Join operations merge tables based on matching values in key columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example tables\nsamples <- tibble(\n  sample_id = c(\"S1\", \"S2\", \"S3\"),\n  concentration = c(0.1, 0.5, 1.0)\n)\n\nmeasurements <- tibble(\n  sample_id = c(\"S1\", \"S1\", \"S2\", \"S2\", \"S3\", \"S3\"),\n  replicate = c(1, 2, 1, 2, 1, 2),\n  value = c(2.3, 2.1, 5.4, 5.6, 10.2, 10.8)\n)\n\n# Join tables\nleft_join(measurements, samples, by = \"sample_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  sample_id replicate value concentration\n  <chr>         <dbl> <dbl>         <dbl>\n1 S1                1   2.3           0.1\n2 S1                2   2.1           0.1\n3 S2                1   5.4           0.5\n4 S2                2   5.6           0.5\n5 S3                1  10.2           1  \n6 S3                2  10.8           1  \n```\n\n\n:::\n:::\n\n\n### Types of Joins\n\nDifferent joins handle non-matching rows differently. Understanding when to use each type is important for correct data analysis:\n\n| Join Type | Result |\n|:----------|:-------|\n| `left_join()` | Keep all rows from left table, add matching data from right |\n| `right_join()` | Keep all rows from right table, add matching data from left |\n| `inner_join()` | Keep only rows with matches in both tables |\n| `full_join()` | Keep all rows from both tables |\n| `semi_join()` | Keep rows from left table that have matches in right |\n| `anti_join()` | Keep rows from left table with NO matches in right |\n\nThe `anti_join()` is particularly useful for finding data quality issues—rows that should have matches but don't:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Which measurements have no sample information?\nanti_join(measurements, samples, by = \"sample_id\")\n```\n:::\n\n\n## Additional dplyr Functions\n\nBeyond the five core verbs, dplyr provides many useful functions for common data manipulation tasks.\n\n### Conditional Logic with case_when()\n\nThe `case_when()` function is a vectorized if-else that handles multiple conditions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create sample data\nexpression_data <- tibble(\n  gene = c(\"gene_A\", \"gene_B\", \"gene_C\", \"gene_D\"),\n  fold_change = c(0.5, 1.2, 3.5, -2.1)\n)\n\nexpression_data |>\n  mutate(\n    regulation = case_when(\n      fold_change > 2 ~ \"strongly up\",\n      fold_change > 1 ~ \"up\",\n      fold_change < -1 ~ \"down\",\n      TRUE ~ \"unchanged\"  # default case\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  gene   fold_change regulation \n  <chr>        <dbl> <chr>      \n1 gene_A         0.5 unchanged  \n2 gene_B         1.2 up         \n3 gene_C         3.5 strongly up\n4 gene_D        -2.1 down       \n```\n\n\n:::\n:::\n\n\n### Counting with count() and n_distinct()\n\nThe `count()` function is a shortcut for grouping and counting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Equivalent to: group_by(x) |> summarize(n = n())\ndata |> count(treatment)\n\n# Sort by count\ndata |> count(treatment, sort = TRUE)\n```\n:::\n\n\nUse `n_distinct()` inside `summarize()` to count unique values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count unique samples per treatment group\ndata |>\n  group_by(treatment) |>\n  summarize(n_samples = n_distinct(sample_id))\n```\n:::\n\n\n### Selecting Rows by Position with slice()\n\nWhile `filter()` selects rows by condition, `slice()` selects by position:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First 3 rows\nhead(iris, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n```\n\n\n:::\n\n```{.r .cell-code}\n# Using slice variants\niris |> slice_head(n = 3)    # First 3 rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n```\n\n\n:::\n\n```{.r .cell-code}\niris |> slice_tail(n = 3)    # Last 3 rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1          6.5         3.0          5.2         2.0 virginica\n2          6.2         3.4          5.4         2.3 virginica\n3          5.9         3.0          5.1         1.8 virginica\n```\n\n\n:::\n\n```{.r .cell-code}\niris |> slice_sample(n = 5)  # Random 5 rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1          5.8         2.7          5.1         1.9  virginica\n2          4.6         3.1          1.5         0.2     setosa\n3          4.6         3.4          1.4         0.3     setosa\n4          5.4         3.4          1.7         0.2     setosa\n5          5.7         2.8          4.1         1.3 versicolor\n```\n\n\n:::\n\n```{.r .cell-code}\niris |> slice_max(Sepal.Length, n = 3)  # Top 3 by value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1          7.9         3.8          6.4         2.0 virginica\n2          7.7         3.8          6.7         2.2 virginica\n3          7.7         2.6          6.9         2.3 virginica\n4          7.7         2.8          6.7         2.0 virginica\n5          7.7         3.0          6.1         2.3 virginica\n```\n\n\n:::\n:::\n\n\n### Extracting Columns with pull()\n\nTo extract a single column as a vector (rather than a data frame), use `pull()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Returns a vector, not a data frame\niris |>\n  filter(Species == \"setosa\") |>\n  pull(Sepal.Length) |>\n  mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.006\n```\n\n\n:::\n:::\n\n\n### Distinct Values with distinct()\n\nRemove duplicate rows based on specified columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Unique values in one column\ndata |> distinct(treatment)\n\n# Unique combinations of multiple columns\ndata |> distinct(treatment, time_point)\n```\n:::\n\n\n## Working with Factors\n\nFactors are R's way of representing categorical data with a fixed set of possible values (called levels). The **forcats** package (part of tidyverse) provides tools for working with factors.\n\n### Reordering Factor Levels\n\nFor visualization, you often want factor levels ordered by a value rather than alphabetically:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sample data\ngene_data <- tibble(\n  gene = c(\"BRCA1\", \"TP53\", \"EGFR\", \"KRAS\", \"MYC\"),\n  expression = c(5.2, 8.1, 3.4, 6.7, 9.2)\n)\n\n# Default: alphabetical order\nggplot(gene_data, aes(x = gene, y = expression)) +\n  geom_col() +\n  labs(title = \"Default (Alphabetical) Order\")\n```\n\n::: {.cell-output-display}\n![](05-tidy-data_files/figure-html/unnamed-chunk-24-1.png){width=576}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reorder by expression value\nlibrary(forcats)\ngene_data |>\n  mutate(gene = fct_reorder(gene, expression)) |>\n  ggplot(aes(x = gene, y = expression)) +\n  geom_col() +\n  labs(title = \"Ordered by Expression\")\n```\n\n::: {.cell-output-display}\n![](05-tidy-data_files/figure-html/unnamed-chunk-25-1.png){width=576}\n:::\n:::\n\n\n### Recoding Factor Levels\n\nUse `fct_recode()` to change level names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Original factor\nstatus <- factor(c(\"WT\", \"WT\", \"KO\", \"HET\", \"KO\"))\n\n# Recode to more descriptive names\nfct_recode(status,\n  \"Wild Type\" = \"WT\",\n  \"Knockout\" = \"KO\",\n  \"Heterozygous\" = \"HET\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Wild Type    Wild Type    Knockout     Heterozygous Knockout    \nLevels: Heterozygous Knockout Wild Type\n```\n\n\n:::\n:::\n\n\n### Collapsing Rare Levels\n\nUse `fct_lump_n()` to combine infrequent categories into \"Other\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sample with many categories\nmany_categories <- factor(rep(c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"),\n                               c(50, 30, 10, 5, 3, 2)))\n\n# Keep only the top 3 most common\nfct_lump_n(many_categories, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] A     A     A     A     A     A     A     A     A     A     A     A    \n [13] A     A     A     A     A     A     A     A     A     A     A     A    \n [25] A     A     A     A     A     A     A     A     A     A     A     A    \n [37] A     A     A     A     A     A     A     A     A     A     A     A    \n [49] A     A     B     B     B     B     B     B     B     B     B     B    \n [61] B     B     B     B     B     B     B     B     B     B     B     B    \n [73] B     B     B     B     B     B     B     B     C     C     C     C    \n [85] C     C     C     C     C     C     Other Other Other Other Other Other\n [97] Other Other Other Other\nLevels: A B C Other\n```\n\n\n:::\n:::\n\n\n## Additional tidyr Functions\n\n### Separating and Combining Columns\n\n`separate()` splits one column into multiple columns; `unite()` combines columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data with combined values\ncombined_data <- tibble(\n  sample = c(\"control_rep1\", \"control_rep2\", \"treatment_rep1\"),\n  value = c(10, 12, 25)\n)\n\n# Separate into treatment and replicate\ncombined_data |>\n  separate(sample, into = c(\"treatment\", \"replicate\"), sep = \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  treatment replicate value\n  <chr>     <chr>     <dbl>\n1 control   rep1         10\n2 control   rep2         12\n3 treatment rep1         25\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combine columns\ntibble(year = 2024, month = 3, day = 15) |>\n  unite(date, year, month, day, sep = \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  date     \n  <chr>    \n1 2024-3-15\n```\n\n\n:::\n:::\n\n\n### Handling Implicit Missing Values with complete()\n\nSometimes data has implicit missing values—combinations that should exist but don't appear. `complete()` makes them explicit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Implicit missing: no observation for site B in year 2021\nobservations <- tibble(\n  site = c(\"A\", \"A\", \"B\"),\n  year = c(2020, 2021, 2020),\n  count = c(10, 15, 8)\n)\n\n# Make all combinations explicit\nobservations |>\n  complete(site, year, fill = list(count = 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  site   year count\n  <chr> <dbl> <dbl>\n1 A      2020    10\n2 A      2021    15\n3 B      2020     8\n4 B      2021     0\n```\n\n\n:::\n:::\n\n\n## Practice Exercises\n\nHere is a workflow to practice these concepts:\n\n1. Read a dataset into R\n2. Convert it to a tibble with `as_tibble()`\n3. Select the columns you need\n4. Filter to the observations of interest\n5. Create new variables with mutate\n6. Group by categorical variables and summarize\n7. Visualize the results\n\nWorking through this process with your own data will cement these concepts better than any number of examples.\n\nFor additional hands-on practice with data wrangling, see @sec-ex-tidy in the Practice Exercises appendix. The exercises include:\n\n- Practice with the five core dplyr verbs\n- Grouping and summarizing data\n- Building data wrangling pipelines\n- Reshaping data with pivot operations\n- Joining multiple data tables\n",
    "supporting": [
      "05-tidy-data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}