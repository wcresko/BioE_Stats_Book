{
  "hash": "75d45bad72dd9e059d40c36d612fe411",
  "result": {
    "engine": "knitr",
    "markdown": "# Tidy Data and Data Wrangling {#sec-tidy-data}\n\n\n::: {.cell}\n\n:::\n\n\n![](../images/week_01.005.jpeg){fig-align=\"center\"}\n\n## What is Tidy Data?\n\nData comes in many shapes, and not all shapes are equally convenient for analysis. The concept of \"tidy data\" provides a standard way to organize data that works well with R and makes many analyses straightforward. In tidy data, each variable forms a column, each observation forms a row, and each type of observational unit forms a table.\n\n![](../images/week_01.006.jpeg){fig-align=\"center\"}\n\nThis structure might seem obvious, but real-world data rarely arrives in tidy form. Spreadsheets often encode information in column names, spread a single variable across multiple columns, or combine multiple variables in a single column. Data wrangling is the process of transforming messy data into tidy data.\n\n## Rules of Thumb for Data Organization\n\nWhether you are creating a new dataset or cleaning an existing one, following these principles will save you time and frustration.\n\nStore a copy of your data in nonproprietary formats like plain text CSV files. Proprietary formats can become unreadable as software changes. Keep an uncorrected copy of your original data separate from any cleaned or processed versions. Use descriptive names for files and variables that convey meaning without requiring external documentation. Include a header row with variable names. Maintain metadata—a data dictionary explaining what each variable means, how it was measured, and what units it uses.\n\nWhen you add new observations, add rows. When you add new variables, add columns. A column should contain only one data type—don't mix numbers and text in the same column. Dates should be in a consistent format. Missing values should be represented consistently, typically as empty cells or `NA` in R.\n\n## Types of Data\n\nUnderstanding the types of data you are working with guides how you analyze them.\n\n**Categorical data** classify observations into groups. Nominal categorical data have no inherent order—for example, species names, treatment groups, or colors. Ordinal categorical data have a meaningful order—ratings like \"low,\" \"medium,\" and \"high,\" or educational levels. In R, categorical data are often represented as factors, which store both the values and the set of possible levels.\n\n**Quantitative data** are numerical measurements. Interval data have meaningful differences between values but no true zero point—temperature in Celsius, where 0° does not mean \"no temperature.\" Ratio data have a true zero and meaningful ratios—mass, length, counts, where zero means \"none\" and twice as much is twice as much.\n\n| Categorical | | Quantitative | |\n|:--:|:--:|:--:|:--:|\n| Ordinal | Nominal | Ratio | Interval |\n| small, medium, large | apples, oranges | kilograms, dollars | temperature, calendar year |\n| ordered character | character | numeric | integer |\n\n## The Tidyverse\n\nThe tidyverse is a collection of R packages designed for data science. These packages share a common philosophy and are designed to work together seamlessly. The core tidyverse packages include `ggplot2` for visualization, `dplyr` for data manipulation, `tidyr` for reshaping data, `readr` for reading data files, and several others.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nLoading the tidyverse loads all core packages at once. The message shows which packages are attached and notes any functions that conflict with base R or other packages.\n\n![](../images/week_3.011.jpeg){fig-align=\"center\"}\n\n## Tibbles\n\nTibbles are the tidyverse's enhanced data frames. They print more informatively, showing only the first few rows and as many columns as fit on screen, along with the dimensions and column types.\n\n![](../images/week_3.012.jpeg){fig-align=\"center\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a tibble\nmy_tibble <- tibble(\n  name = c(\"Alice\", \"Bob\", \"Carol\"),\n  score = c(85, 92, 78),\n  passed = c(TRUE, TRUE, TRUE)\n)\nmy_tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  name  score passed\n  <chr> <dbl> <lgl> \n1 Alice    85 TRUE  \n2 Bob      92 TRUE  \n3 Carol    78 TRUE  \n```\n\n\n:::\n:::\n\n\nThe column types are shown below the column names: `<chr>` for character, `<dbl>` for double (numeric), and `<lgl>` for logical.\n\n## Key dplyr Verbs\n\nThe `dplyr` package provides a grammar for data manipulation. Five key verbs handle most data manipulation tasks.\n\n### filter(): Subset Rows\n\n`filter()` selects rows that meet specified conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Flights in November or December\nfilter(flights, month == 11 | month == 12)\n\n# Flights with arrival delay greater than 2 hours\nfilter(flights, arr_delay > 120)\n```\n:::\n\n\nConditions use comparison operators: `==` (equals), `!=` (not equals), `<`, `>`, `<=`, `>=`. Combine conditions with `&` (and) and `|` (or). The `%in%` operator checks membership in a set.\n\n### select(): Choose Columns\n\n`select()` picks columns by name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select specific columns\nselect(flights, year, month, day)\n\n# Select a range of columns\nselect(flights, year:day)\n\n# Drop columns\nselect(flights, -year, -month)\n```\n:::\n\n\n### arrange(): Sort Rows\n\n`arrange()` reorders rows by column values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sort by year, then month, then day\narrange(flights, year, month, day)\n\n# Sort in descending order\narrange(flights, desc(dep_delay))\n```\n:::\n\n\n### mutate(): Create New Columns\n\n`mutate()` adds new columns that are functions of existing columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(flights,\n  gain = arr_delay - dep_delay,\n  hours = air_time / 60,\n  gain_per_hour = gain / hours\n)\n```\n:::\n\n\n### summarize(): Aggregate Data\n\n`summarize()` collapses multiple rows into summary values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize(flights, \n  mean_delay = mean(dep_delay, na.rm = TRUE),\n  n = n()\n)\n```\n:::\n\n\nThe `na.rm = TRUE` argument tells `mean()` to ignore missing values. The `n()` function counts rows.\n\n## Grouping with group_by()\n\nThe real power of `summarize()` emerges when combined with `group_by()`, which splits data into groups for separate analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by destination, then summarize\nby_dest <- group_by(flights, dest)\nsummarize(by_dest, \n  count = n(),\n  mean_delay = mean(arr_delay, na.rm = TRUE)\n)\n```\n:::\n\n\nThis calculates summary statistics separately for each destination.\n\n## The Pipe Operator\n\nChaining multiple operations together can become unwieldy with nested function calls. The pipe operator `|>` (or the tidyverse's `%>%`) passes the result of one operation as the first argument of the next, allowing you to read operations left-to-right, top-to-bottom.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Without pipe: nested and hard to read\nsummarize(group_by(filter(flights, !is.na(arr_delay)), dest), \n          mean_delay = mean(arr_delay))\n\n# With pipe: clear sequence of operations\nflights |>\n  filter(!is.na(arr_delay)) |>\n  group_by(dest) |>\n  summarize(mean_delay = mean(arr_delay))\n```\n:::\n\n\nRead the pipe as \"then\"—take flights, then filter, then group, then summarize.\n\n![](../images/week_3.015.jpeg){fig-align=\"center\"}\n\n## Handling Missing Values\n\nMissing values are a fact of life in real data. In R, missing values are represented as `NA`. Most operations involving `NA` return `NA`, which can cause problems if you are not careful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, NA, 4)\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.333333\n```\n\n\n:::\n:::\n\n\nCheck for missing values with `is.na()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(is.na(x))  # count missing values\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\nFilter out missing values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[!is.na(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 4\n```\n\n\n:::\n:::\n\n\nOr use tidyr functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove rows with any missing values\ndrop_na(data)\n\n# Remove rows with missing values in specific columns\ndrop_na(data, column_name)\n```\n:::\n\n\n## Reshaping Data\n\nSometimes data is not in the right shape for your analysis. The `tidyr` package provides functions to reshape data.\n\n`pivot_longer()` takes wide data (variables spread across columns) and makes it long (variables stacked in rows). `pivot_wider()` does the reverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: wide data\nwide_data <- tibble(\n  sample = c(\"A\", \"B\", \"C\"),\n  treatment_1 = c(10, 15, 12),\n  treatment_2 = c(8, 14, 11)\n)\nwide_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  sample treatment_1 treatment_2\n  <chr>        <dbl>       <dbl>\n1 A               10           8\n2 B               15          14\n3 C               12          11\n```\n\n\n:::\n\n```{.r .cell-code}\n# Convert to long format\nlong_data <- wide_data |>\n  pivot_longer(\n    cols = starts_with(\"treatment\"),\n    names_to = \"treatment\",\n    values_to = \"response\"\n  )\nlong_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  sample treatment   response\n  <chr>  <chr>          <dbl>\n1 A      treatment_1       10\n2 A      treatment_2        8\n3 B      treatment_1       15\n4 B      treatment_2       14\n5 C      treatment_1       12\n6 C      treatment_2       11\n```\n\n\n:::\n:::\n\n\n## Joining Data\n\nOften data comes in multiple tables that need to be combined. Join operations merge tables based on matching values in key columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example tables\nsamples <- tibble(\n  sample_id = c(\"S1\", \"S2\", \"S3\"),\n  concentration = c(0.1, 0.5, 1.0)\n)\n\nmeasurements <- tibble(\n  sample_id = c(\"S1\", \"S1\", \"S2\", \"S2\", \"S3\", \"S3\"),\n  replicate = c(1, 2, 1, 2, 1, 2),\n  value = c(2.3, 2.1, 5.4, 5.6, 10.2, 10.8)\n)\n\n# Join tables\nleft_join(measurements, samples, by = \"sample_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  sample_id replicate value concentration\n  <chr>         <dbl> <dbl>         <dbl>\n1 S1                1   2.3           0.1\n2 S1                2   2.1           0.1\n3 S2                1   5.4           0.5\n4 S2                2   5.6           0.5\n5 S3                1  10.2           1  \n6 S3                2  10.8           1  \n```\n\n\n:::\n:::\n\n\n## Practice Exercise\n\nHere is a workflow to practice these concepts:\n\n1. Read a dataset into R\n2. Convert it to a tibble with `as_tibble()`\n3. Select the columns you need\n4. Filter to the observations of interest\n5. Create new variables with mutate\n6. Group by categorical variables and summarize\n7. Visualize the results\n\nWorking through this process with your own data will cement these concepts better than any number of examples.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}